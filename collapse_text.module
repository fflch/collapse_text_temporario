<?php


/**
 * @file
 * collapse_text is an input filter that allows text to be collapsible
 *
 * Attributions not otherwhere noted:
 * - #259535 and #233877, ability to specify title in tag. Thanks rivena, Justyn
 * - #233877 requested ability to have nested tags.
 */

/**
 * Implements hook_filter_info().
 */
function collapse_text_filter_info () {
  $filters = array();
  
  $filters['collapse_text_filter'] = array(
    'title'            => t('Collapsible text blocks'),
    'description'      => t('Allows the creation of collapsing blocks of text. This filter must be after the "Limit allowed HTML tags" filter, and should be after the "Convert line breaks into HTML" filter.'),
    'tips callback'    => '_collapse_text_filter_tips',
    'prepare callback' => '_collapse_text_filter_prepare',
    'process callback' => '_collapse_text_filter_process',
    'cache'            => TRUE,
  );
  
  return $filters;
}

/**
 * Implements hook_filter_FILTER_tips().
 */
function _collapse_text_filter_tips ($filter, $format, $long) {
  if ($long) {
    return t(
        '<p>You may surround a section of text with "[collapse]" and "[/collapse]" to it into a collapsible section.</p>'
      . '<p>You may use "[collapse]" tags within other "[collapse]" tags for nested collapsing sections.</p>'
      . '<p>If you start with "[collapsed]" or "[collapse collapsed]", the section will default to a collapsed state.</p>'
      . '<p>You may specify a title for the section in two ways. You may add a "title=" parameter to the opening tag, such as "[collapse title=&lt;your title here&gt;]". In this case, you should surround the title with double-quotes. If you need to include double-quotes in the title, use the html entity "&amp;quot;". For example: \'[collapse title="&amp;quot;Once upon a time&amp;quot;"]\'. If a title is not specified in the "[collapse]" tag, the title will be taken from the first heading found inside the section. A heading is specified using the "&lt;hX&gt;" html tag, where X is a number from 1-6. The heading will be removed from the section in order to prevent duplication. If a title is not found using these two methods, a default title will be supplied.</p>'
      . '<p>For advanced uses, you may also add a "class=" option to specify CSS classes to be added to the section. The CSS classes should be surrounded by double-quotes, and separated by spaces; e.g. \'[collapse class="class1 class2"]\'.</p>'
      . '<p>You may combine these options in (almost) any order. The "collapsed" option should always come first; things will break if it comes after "title=" or "style=". If you need to have it come after the other options, you must specify it as \'collapsed="collapsed"\'; e.g. \'[collapse title="foo" collapsed="collapsed"]\'.</p>'
      . '<p>If you wish to put the string "[collapse" into the document, you will need to prefix it with a backslash ("\\"). The first backslash before any instance of "[collapse" or "[/collapse" will be removed, all others will remain. Thus, if you want to display "[collapse stuff here", you should enter "\\[collapse stuff here". If you wish to display "\\[collapse other stuff", you will need to put in "\\\\[collapse other stuff". If you prefix three backslashes, two will be displayed, etc.</p>'
      . '<p>If you prefer, you can use angle brackets ("&lt;&gt;") instead of straight brackets ("[]"). This module will find any instance of "&lt;collapse" and change it to "[collapse" (also fixing the end of the tags and the closing tags).</p>'
      . '<p>This module supports some historical varients of the tag as well. The following are <strong>not</strong> recommended for any new text, but are left in place so that old uses still work. The "class=" option used to called "style=", and "style=" will be changed into "class=". If you don\'t put a double-quote immediately after "class=", everything up to the end of the tag or the string "title=" will be interpreted as the class string. Similarly, if you don\'t have a double-quote immediately following "title=", everything up to the end of the tag will be used as the title. Note that in this format, "style=" <em>must</em> preceed "title=".</p>'
    );
  }
  else {
    return t('Use [collapse] and [/collapse] to create collapsbile text blocks. [collapse collapsed] or [collapsed] will start with the block closed.'); 
  }
}

/**
 * Implements hook_filter_FILTER_prepare().
 *
 * Convert any html style tags into bracket style.
 * @todo create a better delimiter...
 * Attempt to add quotes where needed for title= and style=
 */
function _collapse_text_filter_prepare ($text, $filter, $format, $langcode, $cache, $cache_id) {
  // fix any html style (ie, '<>' delimited) tags into our '[]' style delimited tags
  $text = preg_replace(
    '/(?<!\\\\)<(\/?collapse[^>]*)>/i',
    '[$1]',
    $text
  );
  
  $text = preg_replace_callback(
    '/(?<!\\\\)\[collapse[^\]]*\]/i',
    '_collapse_text_filter_prepare_regex_callback',
    $text
  );
  
  return $text;
}

/**
 * callback function for the prepare replacement.
 * attempt to clean up poorly formatted tags
 */
function _collapse_text_filter_prepare_regex_callback ($matches) {
  $tag = $matches[0];
  
  // allow the [collapsed] open tag
  $tag = preg_replace(
    '/^\[(collapsed(?: |\]))/i',
    '[collapse $1',
    $tag
  );
  
  // fix the collapsed element
  $tag = preg_replace(
    '/^\[collapse collapsed( |\])/i',
    '[collapse collapsed="collapsed"$1',
    $tag
  );
  
  // fix the style element. going forward, we prefer "class=".
  $tag = preg_replace(
    '/ style=([^"].*?)(?= collapsed=| title=|\])/i',
    ' class="$1"',
    $tag
  );
  $tag = preg_replace(
    '/ style="/i',
    ' class="',
    $tag
  );
  
  // fix the title element
  // not sufficient if title includes double-quotes
  $tag = preg_replace(
    '/ title=([^"].*?)(?= collapsed=| class=|\])/i',
    ' title="$1"',
    $tag
  );
  
  return $tag;
}

/**
 * Implements hook_filter_FILTER_process().
 *
 * This function uses a pseudo-"parser". Earlier versions used a
 * (very complex) regular expression, but I think this verion will
 * work better and have fewer memory issues.
 */
function _collapse_text_filter_process ($text, $filter, $format, $langcode, $cache, $cache_id) {
  // find all of the collapse tags and their location in the string
  $matches = array();
  $regex = '/
    (?<!\\\\)     # not proceeded by a backslash
    \[            # opening bracket
    \/?           # a closing tag?
    collapse      # the word collapse
    [^\]]*        # everything until the closing bracket
    \]            # a closing bracket
  /smx';
  preg_match_all($regex, $text, $matches, PREG_OFFSET_CAPTURE);
  
  // determine the level of nesting for each element.
  $levels = array();
  $curr_level = 0;
  foreach ($matches[0] as $item) {
    // determine whether this is an open or close tag
    $type = 'unknown';
    if (substr($item[0], 0, 9) == '[collapse') {
      $type = 'start';
    }
    elseif (substr($item[0], 0, 10) == '[/collapse') {
      $type = 'end';
    }
    
    // note that the level of an open tag is incremented before we save
    // its information, while the level of a close tag in decremented after
    
    if ($type == 'start') {
      $curr_level++;
    }
    
    $levels[] = array(
      'type'  => $type,
      'tag'   => $item[0],
      'start' => $item[1],
      'end'   => $item[1] + strlen($item[0]),
      'level' => $curr_level,
    );

    if ($type == 'end') {
      $curr_level--;
    }
  }
  
  // process the text if there are any collapse tags...
  if (count($levels)) {
    // turn the levels and the string into a structured tree
    $tree = _collapse_text_process_recurse_levels($text, 0, strlen($text), $levels);
    
    // take the tree, and turn it into FAPI elements, then embed
    // them in a form
    // see #634666, per deviantintegral
    // @todo is there a problem with using the form #type?
    // if so, change the theme function to just return <form>$text</form>
    $form = array(
      '#type'  => 'form',
      '#theme' => 'collapse_text_form',
      'collapsed_internal_text' => _collapse_text_process_recurse_tree($tree),
    );
    
    // render the form back to a string
    $text = drupal_render($form);
    drupal_add_library('system', 'drupal.collapse');
      // by adding this here, our preprocess function doesn't need to actually
      // recurse through the entire page array. This may be faster...
  }
  
  return $text;
}

/**
 * translate the flat levels array into a tree.
 *
 * this function is recursive.
 */
function _collapse_text_process_recurse_levels ($string, $string_start, $string_end, $elements) {
  
  $text_start = $string_start;
  $text_length = $string_end - $string_start;
  $child_start = $string_start;
  $child_end = $string_end;
  $slice_start = -1;
  $slice_end = count($elements);

  // find the first start element
  $elt_start_found = FALSE;
  $elt_start = 0;
  while((! $elt_start_found) and ($elt_start < count($elements))) {
    if ($elements[$elt_start]['type'] == 'start') {
      $elt_start_found = TRUE;
    }
    else {
      $elt_start++;
    }
  }
  
  if ($elt_start_found) {
    // if there is an opening element, set the text length to everything up to it
    $text_length = $elements[$elt_start]['start'] - $string_start;
    $child_start = $elements[$elt_start]['end'];
    $slice_start = $elt_start + 1;
  }
  else {
    // otherwise, return everything in this segment as a string
    return array(array(
      'type'  => 'text',
      'value' => substr($string, $text_start, $text_length),
    ));
  }
  
  // find the next end element at the same level
  $elt_end_found = FALSE;
  $elt_end = $elt_start;
  while((! $elt_end_found) and ($elt_end < count($elements))) {
    if (($elements[$elt_end]['type'] == 'end') and ($elements[$elt_end]['level'] == $elements[$elt_start]['level'])) {
      $elt_end_found = TRUE;
    }
    else {
      $elt_end++;
    }
  }
  
  if ($elt_end_found) {
    $child_end = $elements[$elt_end]['start'];
    $slice_length = $elt_end - $slice_start;
  }
  else {
    // there is a matching failure
    // try skipping the start element...
    if (($elt_start + 1) < count($elements)) {
      return _collapse_text_process_recurse_levels($string, $string_start, $string_end, array_slice($elements, $elt_start + 1));
    }
    else {
      // fall back to just returning the string...
      $text_length = $string_end - $text_start; // reset the text length
      return array(array(
        'type' => 'text',
        'value' => substr($string, $text_start, $text_length),
      ));
    }
  }
  
  
  $parts = array();
  
  // add the text before the opening element
  $parts[] = array(
    'type'  => 'text',
    'value' => substr($string, $text_start, $text_length),
  );
  
  // add the child element
  $parts[] = array(
    'type'  => 'child',
    'tag'   => $elements[$elt_start]['tag'],
    'value' => _collapse_text_process_recurse_levels($string, $child_start, $child_end, array_slice($elements, $slice_start, $slice_length)),
  );
  
  // tail recurse (which ideally could be optimized away, although it won't be...) to handle
  // any siblings
  $parts = array_merge($parts,
                       _collapse_text_process_recurse_levels($string, $elements[$elt_end]['end'], $string_end, array_slice($elements, $elt_end)));
  
  // return the result
  return $parts;
}

/**
 * Take a nested tree and turn it into a string.
 *
 * This function is recursive.
 */
function _collapse_text_process_recurse_tree ($tree) {
  $parts = array();
  
  foreach ($tree as $item) {
    // iterate over the tree
    if ($item['type'] == 'text') {
      $parts[] = _collapse_text_process_text_item($item['value']);
    }
    elseif ($item['type'] = 'child') {
      $parts[] = _collapse_text_process_child_item($item);
    }
  }
  
  return $parts;
}

/**
 * process a text item.
 */
function _collapse_text_process_text_item ($item) {

  // remove any leftover [collapse] or [/collapse] tags, such as might be caused by the teaser
  // leaving out the closing tag. Note that a backslash before the collapse tag will act
  // as an escape.
  $item = preg_replace('/(?<!\\\\)\[\/?collapse[^\]]*\]/', '', $item);

  // remove the first backslash before any collapse tags. This allows collapse tags to be
  // escaped.
  $item = str_replace(array('\\[collapse', '\\[/collapse'),
                      array('[collapse',   '[/collapse'),
                      $item);

  // clear out some miscellaneous tags that are introduced by visual editors...
  $item = preg_replace('/^<\/p>/', '', $item); // close paragraph right at the start
  $item = preg_replace('/<p(?:\s[^>]*)?>$/', '', $item); // open paragraph right at the end
  
  // clear out cruft introduced by the html line ending filter
  // these are probably more controversial, since they may actually be intended...
  $item = preg_replace('/^<br ?\/?>/', '', $item); // <br> at the very start
  $item = preg_replace('/<br ?\/?>$/', '', $item); // <br> at the very end
  
  return array(
    '#type'   => 'markup',
    '#markup' => $item,
  );
}

/**
 * process a child item.
 */
function _collapse_text_process_child_item ($item) {
  
  // translate the "tag" into a proper tag, and then parse it
  // as an xml tag; this is more robust than the previous method
  $tag = preg_replace(
    array('/^\[/', '/\]$/'),
    array('<',     '/>'),
    $item['tag']
  );
  $xmltag = simplexml_load_string($tag);
  
  $collapsed = ($xmltag['collapsed'] == 'collapsed');
  $class     = trim($xmltag['class']);
  $title     = htmlentities(trim($xmltag['title']));
  
  // set up the styles array. We need to include the 'collapsible' and 'collapsed'
  // classes ourself, because this is no longer done by the theme system.
  $classes = array();
  $classes[] = drupal_clean_css_identifier('collapse-text-fieldset');
  $classes[] = 'collapsible';
  if ($collapsed) {
    $classes[] = 'collapsed'; 
  }
  
  // change the style item into an array
  // older versions used a custom safe id function, but
  // I've gone to using the core Drupal function.
  foreach (explode(' ' , $class) as $s) {
    $classes[] = drupal_clean_css_identifier($s);
  }
  
  // if a title is not supplied, look in the first child for a header tag
  if (empty($title)) {
    if ($item['value'][0]['type'] == 'text') {
      $h_matches = array();
      if (preg_match('/(<h\d[^>]*>(.+?)<\/h\d>)/smi', $item['value'][0]['value'], $h_matches)) {
        $title = strip_tags($h_matches[2]);
      }
      
      // if we get the title from the first header tag, we should remove it from
      // the text so that it isn't repeated.
      if (!empty($title)) {
        $occ = 1;
        $item['value'][0]['value'] = str_replace($h_matches[0], '', $item['value'][0]['value'], $occ);
      }
    }
  }
  
  // if still no title, put in some default text
  if (empty($title)) {
    $title = t('Use the arrow to expand or collapse this section');
  }
  
  // create a fieldset that can be themed.
  // per #634666, deviantintegral, although not including the form tag, as we allow nesting.
  $fieldset = array(
    '#type'        => 'fieldset',
    '#theme'       => 'collapse_text_fieldset',
    '#title'       => $title,
    '#collapsible' => TRUE,         // not actually used, but here for correctness
    '#collapsed'   => $collapsed,   // not actually used, but here for correctness
    '#attributes'  => array('class' => $classes),
  );
  
  // add the children, enclosed in a div so that they don't escape from the fieldsets
  $fieldset['collapse_text_contents'] = _collapse_text_process_recurse_tree($item['value']);
  $fieldset['collapse_text_contents']['#prefix'] = '<div class="collapsed-text">';
  $fieldset['collapse_text_contents']['#suffix'] = '</div>';
  
  return $fieldset;
}


/**
 * add the collapse.js file if needed.
 *
 * This is probably the wrong method to take. This may be more intensive than just
 * adding the library to everything, and may mess with aggregated files (?).
 *
 * I have no idea what the right thing to do here is.
 *
 * based on #947710, jrockowitz
 */
function collapse_text_preprocess_page (&$variables) {
  // if collapse.js is not already included
  if ( strpos(drupal_get_js(), 'misc/collapse.js') == FALSE ) {
    // see if we need to add it
    $found = FALSE;
                            // ** there is some kind of recursion issue; the mucking with warnings is to
                            // ** suppress a whole lot of notifications...
    $error_level = error_reporting();
    error_reporting($error_level ^ E_WARNING);
    array_walk_recursive($variables['page'], '_collapse_text_preprocess_page_walk_callback', &$found);
    error_reporting($error_level);
    if ($found) {
      // and if we do, then do so...
      drupal_add_library('system', 'drupal.collapse');
    }
  }
}

function _collapse_text_preprocess_page_walk_callback ($val, $key, &$found) {
  if (($key === '#markup') and ( stripos($val, 'collapse-text-fieldset') !== FALSE )) {
    $found = TRUE;
  }
}

/**
 * Implementation of hook_theme().
 */
function collapse_text_theme ($existing, $type, $theme, $path) {
  return array(
    'collapse_text_fieldset' => array(
      'render element' => 'element',
    ),
    'collapse_text_form' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Theme a section of collapsible text. By default, this function calls the
 * default 'theme_fieldset' implementation, but this function can be overridden
 * to implement a custom theme just for collapsed text.
 *
 * @param $element
 *   An associative array containing the properties of the element.
 *   Properties used: attributes, title, value, description, children, collapsible, collapsed
 * @return
 *   A themed HTML string representing the collapsed text.
 *
 * @ingroup themeable
 */
function theme_collapse_text_fieldset ($element) {
  return drupal_render_children($element['element']);
}

/**
 * Theme the outer form. This is required for the fieldset(s) to validate.
 */
function theme_collapse_text_form ($element) {
  return drupal_render_children($element['element']);
}
