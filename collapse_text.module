<?php


/**
 * @file
 * collapse_text is an input filter that allows text to be collapsible
 *
 * Attributions not otherwhere noted:
 * - #259535 and #233877, ability to specify title in tag. Thanks rivena, Justyn
 * - #233877 requested ability to have nested tags.
 */

/**
 * Implements hook_filter_info().
 */
function collapse_text_filter_info () {
  $filters = array();
  
  $filters['collapse_text_filter'] = array(
    'title'            => t('Collapsible text blocks'),
    'description'      => t('Allows the creation of collapsing blocks of text'),
    'tips callback'    => '_collapse_text_filter_tips',
    'prepare callback' => '_collapse_text_filter_prepare',
    'process callback' => '_collapse_text_filter_process',
    'cache'            => TRUE,
  );
  
  return $filters;
}

/**
 * Implements hook_filter_FILTER_tips().
 */
function _collapse_text_filter_tips ($filter, $format, $long) {
  if ($long) {
    return t('
      Blocks of text surrounded with [collapse] and [/collapse] will be turned
      into collapsible sections. If you start with [collapse collapsed], the
      section will default the collapsed. If you wish, you may specify a title
      using [collapse title="your title here"] (or [collapse collapsed title="your title here"]).
      If no title is specified, the title will be set to the text of the first
      header (&lt;h1&gt;, etc.). In the absence of a header, a default title will
      be used. For theming uses, you may optionally specify a set of classes to
      be added to the section by using [collapse style="classes here"]. The order
      of the options must be [collapse collapsed style="classes" title="title"].
      Any of the options may be omitted, but the order must be the same. Note that
      styles and the title must be enclosed in quotes.
    ');
  }
  else {
    return t('Use "[collapse] and [/collapse] to create collapsbile text blocks. [collapse collapsed] will start with the block closed.'); 
  }
}

/**
 * Implements hook_filter_FILTER_prepare().
 *
 * Convert any html style tags into bracket style.
 * @todo create a better delimiter...
 * Attempt to add quotes where needed for title= and style=
 */
function _collapse_text_filter_prepare ($text, $filter, $format, $langcode, $cache, $cache_id) {
  // fix any html style (ie, '<>' delimited) tags into our '[]' style delimited tags
  $text = preg_replace(
    '/<(\/?collapse[^>]*)>/i',
    '[$1]',
    $text
  );
  
  $text = preg_replace_callback(
    '/\[collapse[^\]]*\]/i',
    '_collapse_text_filter_prepare_regex_callback',
    $text
  );
  
  return $text;
}

/**
 * callback function for the prepare replacement.
 * attempt to clean up poorly formatted tags
 */
function _collapse_text_filter_prepare_regex_callback ($matches) {
  $tag = $matches[0];
  
  // allow the [collapsed] open tag
  $tag = preg_replace(
    '/^\[(collapsed(?: |\]))/i',
    '[collapse $1',
    $tag
  );
  
  // fix the collapsed element
  $tag = preg_replace(
    '/ collapsed( |\])/i',
    ' collapsed="collapsed"$1',
    $tag
  );
  
  // fix the style element
  $tag = preg_replace(
    '/ style=([^"].*?)(?= collapsed=| title=|\])/i',
    ' style="$1"',
    $tag
  );
  
  // fix the title element
  // not sufficient if title includes double-quotes
  $tag = preg_replace(
    '/ title=([^"].*?)(?= collapsed=| style=|\])/i',
    ' title="$1"',
    $tag
  );
  
  return $tag;
}

/**
 * Implements hook_filter_FILTER_process().
 *
 * This function uses a pseudo-"parser". Earlier versions used a
 * (very complex) regular expression, but I think this verion will
 * work better and have fewer memory issues.
 */
function _collapse_text_filter_process ($text, $filter, $format, $langcode, $cache, $cache_id) {
  // find all of the collapse tags and their location in the string
  $matches = array();
  $regex = '/
    (?<!\\\\)     # not proceeded by a backslash
    \[            # opening bracket
    \/?           # a closing tag?
    collapse      # the word collapse
    [^\]]*        # everything until the closing bracket
    \]            # a closing bracket
  /smx';
  preg_match_all($regex, $text, $matches, PREG_OFFSET_CAPTURE);
  
  // determine the level of nesting for each element.
  $levels = array();
  $curr_level = 0;
  foreach ($matches[0] as $item) {
    // determine whether this is an open or close tag
    $type = 'unknown';
    if (substr($item[0], 0, 9) == '[collapse') {
      $type = 'start';
    }
    elseif (substr($item[0], 0, 10) == '[/collapse') {
      $type = 'end';
    }
    
    // note that the level of an open tag is incremented before we save
    // its information, while the level of a close tag in decremented after
    
    if ($type == 'start') {
      $curr_level++;
    }
    
    $levels[] = array(
      'type'  => $type,
      'tag'   => $item[0],
      'start' => $item[1],
      'end'   => $item[1] + strlen($item[0]),
      'level' => $curr_level,
    );

    if ($type == 'end') {
      $curr_level--;
    }
  }
  
  // process the text if there are any collapse tags...
  if (count($levels)) {
    // turn the levels and the string into a structured tree
    $tree = _collapse_text_process_recurse_levels($text, 0, strlen($text), $levels);
    
    // take the tree, and turn it into FAPI elements, then embed
    // them in a form
    // see #634666, per deviantintegral
    // @todo is there a problem with using the form #type?
    // if so, change the theme function to just return <form>$text</form>
    $form = array(
      '#type'  => 'form',
      '#theme' => 'collapse_text_form',
      'collapsed_internal_text' => _collapse_text_process_recurse_tree($tree),
    );
    
    // render the form back to a string
    $text = drupal_render($form);
    drupal_add_library('system', 'drupal.collapse');
  }
  
  return $text;
}

/**
 * translate the flat levels array into a tree.
 *
 * this function is recursive.
 */
function _collapse_text_process_recurse_levels ($string, $string_start, $string_end, $elements) {
  
  $text_start = $string_start;
  $text_length = $string_end - $string_start;
  $child_start = $string_start;
  $child_end = $string_end;
  $slice_start = -1;
  $slice_end = count($elements);

  // find the first start element
  $elt_start_found = FALSE;
  $elt_start = 0;
  while((! $elt_start_found) and ($elt_start < count($elements))) {
    if ($elements[$elt_start]['type'] == 'start') {
      $elt_start_found = TRUE;
    }
    else {
      $elt_start++;
    }
  }
  
  if ($elt_start_found) {
    // if there is an opening element, set the text length to everything up to it
    $text_length = $elements[$elt_start]['start'] - $string_start;
    $child_start = $elements[$elt_start]['end'];
    $slice_start = $elt_start + 1;
  }
  else {
    // otherwise, return everything in this segment as a string
    return array(array(
      'type'  => 'text',
      'value' => substr($string, $text_start, $text_length),
    ));
  }
  
  // find the next end element at the same level
  $elt_end_found = FALSE;
  $elt_end = $elt_start;
  while((! $elt_end_found) and ($elt_end < count($elements))) {
    if (($elements[$elt_end]['type'] == 'end') and ($elements[$elt_end]['level'] == $elements[$elt_start]['level'])) {
      $elt_end_found = TRUE;
    }
    else {
      $elt_end++;
    }
  }
  
  if ($elt_end_found) {
    $child_end = $elements[$elt_end]['start'];
    $slice_length = $elt_end - $slice_start;
  }
  else {
    // there is a matching failure
    // try skipping the start element...
    if (($elt_start + 1) < count($elements)) {
      return _collapse_text_process_recurse_levels($string, $string_start, $string_end, array_slice($elements, $elt_start + 1));
    }
    else {
      // fall back to just returning the string...
      $text_length = $string_end - $text_start; // reset the text length
      return array(array(
        'type' => 'text',
        'value' => substr($string, $text_start, $text_length),
      ));
    }
  }
  
  
  $parts = array();
  
  // add the text before the opening element
  $parts[] = array(
    'type'  => 'text',
    'value' => substr($string, $text_start, $text_length),
  );
  
  // add the child element
  $parts[] = array(
    'type'  => 'child',
    'tag'   => $elements[$elt_start]['tag'],
    'value' => _collapse_text_process_recurse_levels($string, $child_start, $child_end, array_slice($elements, $slice_start, $slice_length)),
  );
  
  // tail recurse (which ideally could be optimized away, although it won't be...) to handle
  // any siblings
  $parts = array_merge($parts,
                       _collapse_text_process_recurse_levels($string, $elements[$elt_end]['end'], $string_end, array_slice($elements, $elt_end)));
  
  // return the result
  return $parts;
}

/**
 * Take a nested tree and turn it into a string.
 *
 * This function is recursive.
 */
function _collapse_text_process_recurse_tree ($tree) {
  $parts = array();
  
  foreach ($tree as $item) {
    // iterate over the tree
    if ($item['type'] == 'text') {
      $parts[] = _collapse_text_process_text_item($item['value']);
    }
    elseif ($item['type'] = 'child') {
      $parts[] = _collapse_text_process_child_item($item);
    }
  }
  
  return $parts;
}

/**
 * process a text item.
 */
function _collapse_text_process_text_item ($item) {

  // remove any leftover [collapse] or [/collapse] tags, such as might be caused by the teaser
  // leaving out the closing tag. Note that a backslash before the collapse tag will act
  // as an escape.
  $item = preg_replace('/(?<!\\\\)\[\/?collapse[^\]]*\]/', '', $item);

  // remove the first backslash before any collapse tags. This allows collapse tags to be
  // escaped.
  $item = str_replace(array('\\[collapse', '\\[/collapse'),
                      array('[collapse',   '[/collapse'),
                      $item);

  // clear out some miscellaneous tags that are introduced by visual editors...
  $item = preg_replace('/^<\/p>/', '', $item); // close paragraph right at the start
  $item = preg_replace('/<p(?:\s[^>]*)?>$/', '', $item); // open paragraph right at the end
  
  // clear out cruft introduced by the html line ending filter
  $item = preg_replace('/^<br ?\/?>/', '', $item);
  
  return array(
    '#type'   => 'markup',
    '#markup' => $item,
  );
}

/**
 * process a child item.
 */
function _collapse_text_process_child_item ($item) {
  
  // translate the "tag" into a proper tag, and then parse it
  // as an xml tag; this is more robust than the previous method
  $tag = preg_replace(
    array('/^\[/', '/ collapsed( |\])/',           '/\]$/'),
    array('<',     ' collapsed="collapsed"\1', '/>'),
    $item['tag']
  );
  $xmltag = simplexml_load_string($tag);
  
  $collapsed = ($xmltag['collapsed'] == 'collapsed');
  $style     = trim($xmltag['style']);
  $title     = htmlentities(trim($xmltag['title']));
  
  // set up the styles array. We need to include the 'collapsible' and 'collapsed'
  // classes ourself, because this is no longer done by the theme system.
  $styles = array();
  $styles[] = drupal_clean_css_identifier('collapse-text-fieldset');
  $styles[] = 'collapsible';
  if ($collapsed) {
    $styles[] = 'collapsed'; 
  }
  
  // change the style item into an array
  // older versions used a custom safe id function, but
  // I've gone to using the core Drupal function.
  foreach (explode(' ' , $style) as $s) {
    $styles[] = drupal_clean_css_identifier($s);
  }
  
  // if a title is not supplied, look in the first child for a header tag
  if (empty($title)) {
    if ($item['value'][0]['type'] == 'text') {
      $h_matches = array();
      if (preg_match('/(<h\d[^>]*>(.+?)<\/h\d>)/smi', $item['value'][0]['value'], $h_matches)) {
        $title = strip_tags($h_matches[2]);
      }
      
      // if we get the title from the first header tag, we should remove it from
      // the text so that it isn't repeated.
      if (!empty($title)) {
        $occ = 1;
        $item['value'][0]['value'] = str_replace($h_matches[0], '', $item['value'][0]['value'], $occ);
      }
    }
  }
  
  // if still no title, put in some default text
  if (empty($title)) {
    $title = t('Use the arrow to expand or collapse this section');
  }
  
  // create a fieldset that can be themed.
  // per #634666, deviantintegral, although not including the form tag, as we allow nesting.
  $fieldset = array(
    '#type'        => 'fieldset',
    '#theme'       => 'collapse_text_fieldset',
    '#title'       => $title,
    '#collapsible' => TRUE,         // not actually used, but here for correctness
    '#collapsed'   => $collapsed,   // not actually used, but here for correctness
    '#attributes'  => array('class' => $styles),
  );
  
  // add the children
  $fieldset['collapse_text_contents'] = _collapse_text_process_recurse_tree($item['value']);
  $fieldset['collapse_text_contents']['#prefix'] = '<div class="collapsed-text">';
  $fieldset['collapse_text_contents']['#suffix'] = '</div>';
  
  return $fieldset;
}


/**
 * add the collapse.js file if needed.
 *
 * per #947710, jrockowitz
 */
function collapse_text_preprocess_page (&$variables) {
  // if collapse.js is not already included
  if ( strpos(drupal_get_js(), 'misc/collapse.js') == FALSE ) {
    // see if we need to add it
    // ** there is some kind of recursion issue; the mucking with warnings is to
    // ** suppress a whole lot of notifications...
    $found = FALSE;
    $error_level = error_reporting();
    error_reporting($error_level ^ E_WARNING);
    array_walk_recursive($variables['page'], '_collapse_text_preprocess_page_walk_callback', &$found);
    error_reporting($error_level);
    if ($found) {
      // and if we do, then do so...
      drupal_add_library('system', 'drupal.collapse');
    }
  }
}

function _collapse_text_preprocess_page_walk_callback ($val, $key, &$found) {
  if (($key === '#markup') and ( stripos($val, 'collapse-text-fieldset') !== FALSE )) {
    $found = TRUE;
  }
}

/**
 * Implementation of hook_theme().
 */
function collapse_text_theme ($existing, $type, $theme, $path) {
  return array(
    'collapse_text_fieldset' => array(
      'render element' => 'element',
    ),
    'collapse_text_form' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Theme a section of collapsible text. By default, this function calls the
 * default 'theme_fieldset' implementation, but this function can be overridden
 * to implement a custom theme just for collapsed text.
 *
 * @param $element
 *   An associative array containing the properties of the element.
 *   Properties used: attributes, title, value, description, children, collapsible, collapsed
 * @return
 *   A themed HTML string representing the collapsed text.
 *
 * @ingroup themeable
 */
function theme_collapse_text_fieldset ($element) {
  return drupal_render_children($element['element']);
}

/**
 * Theme the outer form. This is required for the fieldset(s) to validate.
 */
function theme_collapse_text_form ($element) {
  return drupal_render_children($element['element']);
}
