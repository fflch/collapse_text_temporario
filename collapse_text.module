<?php

// $Id$

/**
 * @file
 * collapse_text is an input filter that allows text to be collapsible
 *
 * Attributions not otherwhere noted:
 * - #259535 and #233877, ability to specify title in tag. Thanks rivena, Justyn
 * - #233877 requested ability to have nested tags.
 */

/**
 * Implementation of hook_filter_tips().
 */
function collapse_text_filter_tips($delta, $format, $long = false) {
  if ($long) {
    return t('Enclose sections of text in [collapse] and [/collapse] to '
      + 'turn them into collapsible sections.  If you use [collapse collapsed] '
      + 'and [/collapse], the section will start out collapsed. You may '
      + 'specify a title with [collapse title=some title] '
      + '(or [collapse collapsed title=some title]). If no title is specified, '
      + 'the title will be taken from the first header '
      + '(&lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, ...) found. In the absence of a '
      + 'header, a default title is used.');
  }
  else {
    return t('Make collapsible text blocks using [collapse] and [/collapse].');
  }
}

/**
 * Implementation of hook_filter().
 */
function collapse_text_filter($op, $delta = 0, $format = -1, $text = '') {
  switch ($op) {
    case 'list':
      return array(
        0 => t('Collapse text')
      );
      break;
      
    case 'description':
      return t('Make collapsing text sections');
      break;
    
    case 'settings':
      // This filter has no user settings.
      break;
    
    case 'no cache':
      return FALSE;
      break;
    
    case 'prepare':
      return $text;
      break;
      
    case 'process':
      return collapse_text_process($text);
      break;
    
    default:
      return $text;
      break;
  }
}

/**
 * Implementation of hook_filter($op='process').
 *
 * Earlier versions of this were done with a regular expression, but that
 * was proving complicated. This version uses its own "parser" to process the text.
 */
function collapse_text_process ($text) {
  $matches = array();
  
  // find all of the collapse tags and their location in the string
  $regex = '/
    (?<!\\\\)     # not proceeded by a backslash
    \[            # opening bracket
    \/?           # a closing tag?
    collapse      # the word collapse
    [^\]]*        # everything until the closing bracket
    \]            # a closing bracket
  /smx';
  preg_match_all($regex, $text, $matches, PREG_OFFSET_CAPTURE);
  
  // determine the level of nesting for each element.
  $levels = array();
  $curr_level = 0;
  foreach ($matches[0] as $item) {
    $type = 'unknown';
    if (substr($item[0], 0, 9) == '[collapse') {
      $type = 'start';
    }
    elseif (substr($item[0], 0, 10) == '[/collapse') {
      $type = 'end';
    }
    
    if ($type == 'start') {
      $curr_level++;
    }
    
    $levels[] = array(
      'type'  => $type,
      'tag'   => $item[0],
      'start' => $item[1],
      'end'   => $item[1] + strlen($item[0]),
      'level' => $curr_level,
    );

    if ($type == 'end') {
      $curr_level--;
    }
  }
  
  // turn the levels and the string into a structured tree
  $tree = _collapse_text_process_recurse_levels($text, 0, strlen($text), $levels);
  
  // take the tree and turn it back into a string
  $text = _collapse_text_process_recurse_tree($tree);
  
  return $text;
}

/**
 * translate the flat levels array into a tree.
 *
 * this function is recursive.
 */
function _collapse_text_process_recurse_levels($string, $string_start, $string_end, $elements) {
  
  $text_start = $string_start;
  $text_length = $string_end - $string_start;
  $child_start = $string_start;
  $child_end = $string_end;
  $slice_start = -1;
  $slice_end = count($elements);

  // find the first start element
  $elt_start_found = FALSE;
  $elt_start = 0;
  while((! $elt_start_found) and ($elt_start < count($elements))) {
    if ($elements[$elt_start]['type'] == 'start') {
      $elt_start_found = TRUE;
    }
    else {
      $elt_start++;
    }
  }
  
  if ($elt_start_found) {
    // if there is an opening element, set the text length to everything up to it
    $text_length = $elements[$elt_start]['start'] - $string_start;
    $child_start = $elements[$elt_start]['end'];
    $slice_start = $elt_start + 1;
  }
  else {
    // otherwise, return everything in this segment as a string
    return array(array(
      'type'  => 'text',
      'value' => substr($string, $text_start, $text_length),
    ));
  }
  
  // find the next end element at the same level
  $elt_end_found = FALSE;
  $elt_end = $elt_start;
  while((! $elt_end_found) and ($elt_end < count($elements))) {
    if (($elements[$elt_end]['type'] == 'end') and ($elements[$elt_end]['level'] == $elements[$elt_start]['level'])) {
      $elt_end_found = TRUE;
    }
    else {
      $elt_end++;
    }
  }
  
  if ($elt_end_found) {
    $child_end = $elements[$elt_end]['start'];
    $slice_length = $elt_end - $slice_start;
  }
  else {
    // there is a matching failure
    // try skipping the start element...
    if (($elt_start + 1) < count($elements)) {
      return _collapse_text_process_recurse_levels($string, $string_start, $string_end, array_slice($elements, $elt_start + 1));
    }
    else {
      // fall back to just returning the string...
      $text_length = $string_end - $text_start; // reset the text length
      return array(array(
        'type' => 'text',
        'value' => substr($string, $text_start, $text_length),
      ));
    }
  }
  
  
  $parts = array();
  
  // add the text before the opening element
  $parts[] = array(
    'type'  => 'text',
    'value' => substr($string, $text_start, $text_length),
  );
  
  // add the child element
  $parts[] = array(
    'type'  => 'child',
    'tag'   => $elements[$elt_start]['tag'],
    'value' => _collapse_text_process_recurse_levels($string, $child_start, $child_end, array_slice($elements, $slice_start, $slice_length)),
  );
  
  // tail recurse (which ideally could be optimized away, although it won't be...) to handle
  // any siblings
  $parts = array_merge($parts,
                       _collapse_text_process_recurse_levels($string, $elements[$elt_end]['end'], $string_end, array_slice($elements, $elt_end)));
  
  // return the result
  return $parts;
}

/**
 * Take a nested tree and turn it into a string.
 *
 * This function is recursive.
 */
function _collapse_text_process_recurse_tree ($tree) {
  $parts = array();
  
  foreach ($tree as $item) {
    // iterate over the tree
    if ($item['type'] == 'text') {
      $parts[] = _collapse_text_process_text_item($item['value']);
    }
    elseif ($item['type'] = 'child') {
      $parts[] = _collapse_text_process_child_item($item);
    }
  }
  
  return join($parts);
}

/**
 * process a text item.
 */
function _collapse_text_process_text_item ($item) {

  // remove any leftover [collapse] or [/collapse] tags, such as might be caused by the teaser
  // leaving out the closing tag
  $item = preg_replace('/(?<!\\\\)\[\/?collapse[^\]]*\]/', '', $item);

  // remove the first backslash before any collapse tags. This allows collapse tags to be
  // escaped.
  $item = str_replace(array('\\[collapse', '\\[/collapse'),
                      array('[collapse',   '[/collapse'),
                      $item);

  // clear out some miscellaneous tags that are introduced by visual editors...
  $item = preg_replace('/^<\/p>/', '', $item); // close paragraph right at the start
  $item = preg_replace('/<p(?:\s[^>]*)?>$/', '', $item); // open paragraph right at the end
  
  return $item;
}

/**
 * process a child item.
 */
function _collapse_text_process_child_item ($item) {

  // parse the tag into parts
  $tag_matches = array();
  preg_match('/\[collapse( collapsed)?(?: style=([^\]]*))?(?: title=([^\]]*))?\]/', $item['tag'], $tag_matches);
  
  $collapsed = ($tag_matches[1] == ' collapsed');      
  $style     = trim($tag_matches[2]);
  $title     = trim($tag_matches[3]);
  
  // clean up quotes on the title and style items
  if (!empty($style)) {
    // remove any leading and trailing quotes
    $style = preg_replace('/^["\']*/', '', $style);
    $style = preg_replace('/["\']*$/', '', $style);
  }
  if (!empty($title)) {
    // remove any leading and trailing quotes
    $title = preg_replace('/^["\']*/', '', $title);
    $title = preg_replace('/["\']*$/', '', $title);
  }
  
  // if a title is not supplied, look in the first child for a header tag
  if (empty($title)) {
    if ($item['value'][0]['type'] == 'text') {
      $h_matches = array();
      preg_match('/(<h\d[^>]*>(.+?)<\/h\d>)/smi', $item['value'][0]['value'], $h_matches);
      $title = strip_tags($h_matches[2]);
      
      // if we get the title from the first header tag, we should remove it from
      // the text so that it isn't repeated.
      if (!empty($title)) {
        $occ = 1;
        $item['value'][0]['value'] = str_replace($h_matches[0], '', $item['value'][0]['value'], $occ);
      }
    }
  }
  
  // if still no title, put in some default text
  if (empty($title)) {
    $title = t('Use the arrow to expand or collapse this section');
  }
  
  // create a fieldset that can be themed.
  // per #634666, deviantintegral, although not including the form tag, as we allow nesting.
  $fieldset = array(
    '#type'        => 'fieldset',
    '#title'       => $title,
    '#collapsible' => TRUE,
    '#collapsed'   => $collapsed,
    '#theme'       => 'collapse_text_fieldset',
  );
  
  // clean up any styles provided, and add our own class
  $fixed_styles = array('collapsed-text-fieldset');
  if (!empty($style)) {
    $styles = explode(' ', $style);
    foreach($styles as $s) {
      $fixed_styles[] = collapse_text_id_safe($s);
    }
  }
  $fieldset['#attributes'] = array(
    'class' => join(" ", $fixed_styles),
  );
  
  // add the children
  $fieldset['collapse_text_contents'] = array(
    '#type'   => 'markup',
    '#prefix' => '<div class="collapsed-text">',
    '#suffix' => '</div>',
    '#value'  => _collapse_text_process_recurse_tree($item['value']),
  );
  
  return drupal_render($fieldset);
}


/**
 * add the collapse.js file if needed.
 *
 * per #947710, jrockowitz
 */
function collapse_text_preprocess_page(&$variables) {
  global $theme;

  // Add collapse.js if a collapsible fieldset is found in a region or the main content.
  if ( strpos($variables['scripts'], 'misc/collapse.js') === FALSE ) {
    $regions = array_keys(system_region_list($theme));
    $regions[] = 'content';
    foreach ($regions as $region) {
      // Using stripos() is much faster then executing preg_match() on every page.
      if ( (stripos($variables[$region], '<fieldset') !== FALSE)
           && (stripos($variables[$region], 'collapsible') !== FALSE) ) {
        drupal_add_js('misc/collapse.js', 'core');
        $variables['scripts'] = drupal_get_js();
        return;
      }
    }
  }
}

/**
 * Implementation of hook_theme().
 */
function collapse_text_theme($existing, $type, $theme, $path) {
  return array(
    'collapse_text_fieldset' => array(
      'arguments' => array('element'),
    ),
  );
}

/**
 * Theme a section of collapsible text. By default, this function calls the
 * default 'theme_fieldset' implementation, but this function can be overridden
 * to implement a custom theme just for collapsed text.
 *
 * @param $element
 *   An associative array containing the properties of the element.
 *   Properties used: attributes, title, value, description, children, collapsible, collapsed
 * @return
 *   A themed HTML string representing the collapsed text.
 *
 * @ingroup themeable
 */
function theme_collapse_text_fieldset($element) {
  return drupal_render($element);
}

/**
 * Converts a string to a suitable html ID attribute.
 * Copied from zen_id_safe() in the Zen theme.
 *
 * http://www.w3.org/TR/html4/struct/global.html#h-7.5.2 specifies what makes a
 * valid ID attribute in HTML. This function:
 *
 * - Ensure an ID starts with an alpha character by optionally adding an 'id'.
 * - Replaces any character except alphanumeric characters with dashes.
 * - Converts entire string to lowercase.
 *
 * @param $string
 *   The string
 * @return
 *   The converted string
 */
function collapse_text_id_safe($string) {
  // Replace with dashes anything that isn't A-Z, numbers, dashes, or underscores.
  $string = strtolower(preg_replace('/[^a-zA-Z0-9-]+/', '-', $string));

  // If the first character is not a-z, add 'id' in front.
  if (!ctype_lower($string{0})) { // Don't use ctype_alpha since its locale aware.
    $string = 'id' . $string;
  }
  return $string;
}
